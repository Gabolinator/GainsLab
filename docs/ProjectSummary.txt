GainsLab is an end-to-end workout content platform composed of three tightly coupled layers built on .NET 9. The solution embraces a layered/hexagonal architecture: domain primitives and contracts live in backend/GainsLab.Core, transport-specific contracts and HTTP adapters sit in backend/GainsLab.Contracts, and infrastructure concerns (EF Core DbContexts, migrations, outbox tables) remain isolated in backend/GainsLab.Infrastructure. This separation keeps the application logic dependency-free while letting API and client layers plug in through shared interfaces.

The backend stack centers on ASP.NET Core (backend/GainsLab.Api) with Entity Framework Core persisting to PostgreSQL, automatically running migrations at startup and exposing sync/health endpoints. API services follow a CQRS-inspired sync model (`ISyncService<T>`) to provide ordered pages of DTOs for pulls while validating pushes, stamping metadata, and queueing outbox entries for downstream delivery. Observability and resiliency are built in through structured logging and health checks so the API can act as the authoritative source of truth.

The desktop experience (desktop/GainsLab.Editor) is currently an Avalonia client that uses those shared contracts to orchestrate seeding, offline caching, and authoring workflows, with a long-term plan to migrate to .NET MAUI for broader cross-platform reach on desktop and mobile form factors. 
Its DataManager and SyncOrchestrator hydrate a local SQLite cache, track cursors (SyncState), and coordinate pulls/pushes through the HTTP provider plus pluggable processors. View models talk only to interfaces such as IDataManager and IComponentCacheRegistry, so transitioning to MAUI primarily affects the presentation shell while preserving sync/orchestration code.

Across the stack, entities carry a DataAuthority flag that enforces ownership rules between upstream (API) and downstream (editor) edits, while an outbox interceptor normalizes payloads to prevent duplicates. 
The sync pipeline flows from API services producing paged DTOs, through the shared HTTP client, to the editorâ€™s local repositories and caches, enabling offline creation while keeping PostgreSQL as the source of truth. Offline-first design, immutable DTOs, and interface-driven composition let features evolve independently and pave the way for converging the Avalonia client into the upcoming MAUI-based shell.
