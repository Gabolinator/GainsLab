

@rendermode InteractiveServer

@using GainsLab.Application.Results
@using GainsLab.Contracts.Dtos.GetDto
@using GainsLab.Domain
@using GainsLab.Domain.Interfaces
@using GainsLab.Infrastructure.Utilities
@using GainsLab.WebLayer.Model
@using GainsLab.WebLayer.Model.Dropdown
@using GainsLab.WebLayer.Model.Dto.Descriptor
@using GainsLab.WebLayer.Model.Dto.MovementCategory
@using ILogger = Domain.Interfaces.ILogger

@implements IDisposable

<h3>MovementCategoryFormComponent</h3>
  
<EditForm EditContext="FormContext" FormName=@FormName OnValidSubmit="HandleSubmit">
    <DataAnnotationsValidator></DataAnnotationsValidator>
    <ValidationSummary></ValidationSummary>
        
            
    <div class="mb-2">
        <label>Name</label>
        <InputText Value="@Model.Name"
                   ValueChanged="OnNameChanged"
                   ValueExpression="@(() => Model.Name)"
                   @oninput="OnNameInput" />
        <ValidationMessage For="(() => Model.Name)"/>
    </div>
            
    <div class="mb-2">
        <label>Description</label>
        <InputText class="form-control"
                   @bind-Value="EditDescriptor.DescriptionContent"/>
    </div>
            
    <div class="mb-2">
        <label>Parent</label>
        <DropdownComponent Config="ParentDropdown"
                           @bind-Value="SelectedParent"/>
    </div>
            
    <div class="mb-2">
        <label>Bases Categories </label>
        <p>  @GetBaseCategoriesText()   </p>
        @foreach (var category in GetAllBaseCategories().OrderBy(c=>c.ToString()))
        {
                    
            if(category == eMovementCategories.undefined) continue;
                    
            <div>
                <CheckboxComponent
                    Label="@category.ToString()"
                    Value="@IsBaseCategorySelected(category)"
                    ValueChanged="(isChecked) => OnBaseCategoryChanged(category, isChecked)" />
            </div>
        }
                
    </div>
    
    
    
    @if (IsValid())
    {
        <button class="btn btn-primary" type="submit">@SubmitButtonText</button>
    }
    
   @if (DisplayBackButton)
    {
        <a href=@BackAddress class="btn btn-primary">@BackButtonText</a>
    }
    

</EditForm>

@code
{


    [Inject] private ILogger Logger { get; set; } = default!;
    [Inject] private IClock Clock { get; set; } = default!;

    
    [Parameter] public MovementCategoryFormDTO Model { get; set; } = new();
    [Parameter] public IReadOnlyList<MovementCategoryRefDTO> AllCategories { get; set; } = new List<MovementCategoryRefDTO>();

    private IReadOnlyList<string>? CategoryNames => AllCategories.Select(c => c.Name).ToList();
    [Parameter] public EventCallback<MovementCategoryFormDTO> OnSubmit { get; set; } = default;
    [Parameter] public bool ValidateNameOnInput { get; set; } = false;
    [Parameter] public string FormName { get; set; } = "MovementCategoryForm";
    [Parameter] public string SubmitButtonText { get; set; } = "Save";
    [Parameter] public bool DisplayBackButton { get; set; } = false;
    [Parameter] public string BackButtonText { get; set; } = "Close";
    [Parameter] public string BackAddress { get; set; } = "/movement-categories";
    

    public DropdownConfig ParentDropdown { get; set; } = default!;
   
    [Parameter] public EventCallback<MessagesContainer> OnMessages { get; set; } = default;

    public MessagesContainer? Messages { get; set; } = new MessagesContainer();
    public DescriptorFormDTO EditDescriptor { get; set; } = new();

    public string SelectedParent { get => _parentFieldID;  set => OnParentChanged(value); }
    private HashSet<eMovementCategories> SelectedBaseCategories = new();
    
    private EditContext? FormContext;
    private ValidationMessageStore? _validationMessages;
    private FieldIdentifier _nameField;
    private bool _isEditValid;
    private string _normalizedOriginalName;
    private string _originalDescriptorContent;
    
    private string _parentFieldID;
    public MovementCategoryRefDTO? ParentRef { get; set; } = null;
    
    private Task OnNameChanged(string value)
    {
        // This is what EditContext uses for standard change notifications
        Model!.Name = value;
        return Task.CompletedTask;
    }

    private void OnNameInput(ChangeEventArgs e)
    {
        Model!.Name = e.Value?.ToString();

        FormContext?.NotifyFieldChanged(_nameField);
    }

    private string GetBaseCategoriesText()
    {
        if(SelectedBaseCategories.Count == 0) return "None";
        
        return string.Join(',', SelectedBaseCategories.OrderBy(c=>c.ToString()).Select(c => c.ToString()));

    }
    
    private IEnumerable<eMovementCategories> GetAllBaseCategories()
        => Enum.GetValues<eMovementCategories>();
    
    private void OnParentChanged(string value)
    {
        _parentFieldID = value;
        if (string.IsNullOrEmpty(value))
        {
            Logger.LogWarning(nameof(MovementCategoryFormComponent), $"Parent Selected : none");
        }
        Logger.Log(nameof(MovementCategoryFormComponent), $"Parent Selected: {value}");
        SetParent(_parentFieldID);
    }

    private void SetParent(string? value)
    {
        if (string.IsNullOrEmpty(value))
        {
            Logger.LogWarning(nameof(MovementCategoryFormComponent), $"Parent Selected : none");
            ParentRef = null;
            return;
        }

        if (!Guid.TryParse(value, out Guid parsedGuid))
        {
            Logger.LogWarning(nameof(MovementCategoryFormComponent), $"Could not parse {value} to GUID");
            ParentRef = null;
            return;
        }

        var cat = AllCategories.FirstOrDefault(c => c.Id == parsedGuid);
        if (cat == null)
        {
            Logger.LogWarning(nameof(MovementCategoryFormComponent), $"Could find category with ID {parsedGuid}");
            ParentRef = null;
            return; 
        }
        Logger.Log(nameof(MovementCategoryFormComponent), $"Parent Selected: {cat.Name}");
        ParentRef = new MovementCategoryRefDTO(parsedGuid, cat.Name);

    }



    private void OnBaseCategoryChanged(eMovementCategories category, bool isChecked)
    {
        if (isChecked)
            SelectedBaseCategories.Add(category);
        else
            SelectedBaseCategories.Remove(category);
        
        Logger.Log(nameof(MovementCategoryFormComponent), $"Category {category} => {isChecked}");
    }

    private bool IsBaseCategorySelected(eMovementCategories category)
        => SelectedBaseCategories.Contains(category);

    

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();

        EditDescriptor = Model.Descriptor;
        
        List<DropdownItem> parentOptions = AllCategories.Where(c=>c.Id != Model.Id).Select(c=>new DropdownItem{Label = c.Name, Value =c.Id.ToString()}).ToList();
        parentOptions.Add(new DropdownItem{Label = "None", Value = ""});
        
        ParentDropdown = new DropdownConfig { Items = parentOptions }; //Placeholder =  "Select BodySection..." , InitialSelectedLabel = m.BodySection.ToString()

        _parentFieldID = Model.Parent != null ? Model.Parent.Id.ToString() : "None";
        
        _normalizedOriginalName = Normalize(Model!.Name);
        _originalDescriptorContent = Normalize(EditDescriptor.DescriptionContent);

        SelectedBaseCategories = GetBaseCategoriesEnum(Model.BasesCategory);
        
        BuildEditContext();


    }

    private HashSet<eMovementCategories> GetBaseCategoriesEnum(List<MovementCategoryRefDTO> basesCategory)
    {
      return basesCategory.Select(c=>Enum.Parse<eMovementCategories>(c.Name)).ToHashSet();
    }


    private void BuildEditContext()
    {
        if (FormContext != null)
        {
            FormContext.OnFieldChanged -= HandleFieldChanged;
            FormContext.OnValidationRequested -= HandleValidationRequested;
        }

        FormContext = new EditContext(Model!);
        _validationMessages = new ValidationMessageStore(FormContext);

        _nameField = FieldIdentifier.Create(() => Model!.Name);

        FormContext.OnFieldChanged += HandleFieldChanged;
        FormContext.OnValidationRequested += HandleValidationRequested;

        ValidateUniqueName();
    }

    private void HandleFieldChanged(object? sender, FieldChangedEventArgs e)
    {
        if (e.FieldIdentifier.FieldName == nameof(MuscleGetDTO.Name))
        {
            ValidateUniqueName();
        }


    }

    private void HandleValidationRequested(object? sender, ValidationRequestedEventArgs e)
    {
        ValidateUniqueName();
    }

    private void ValidateUniqueName()
    {
        if (FormContext == null || _validationMessages == null)
            return;


        _validationMessages.Clear(_nameField);

        Messages ??= new MessagesContainer();

        Messages.Clear(MessageType.Warning);

        var candidate = Normalize(Model.Name);

        if (string.IsNullOrWhiteSpace(candidate))
        {
            _isEditValid = false;
            //  EditMuscle.UpdateRequest = UpdateRequest.DontUpdate;
            FormContext.NotifyValidationStateChanged();
            return;
        }

        if (CategoryNames != null && CategoryNames.Contains(candidate))
        {
            if(_normalizedOriginalName.Equals(Normalize(candidate), StringComparison.InvariantCultureIgnoreCase)) 
                return;
            
            _validationMessages.Add(_nameField, "An Muscle with this name already exists.");
            _isEditValid = false;
            FormContext.NotifyValidationStateChanged();
            return;
        }

        if (string.Equals(candidate, _normalizedOriginalName, StringComparison.InvariantCultureIgnoreCase))
        {
            var warning = $"Validated Muscle Name - unchanged candidate {candidate}";
            Messages.AddWarning(warning);
            _validationMessages.Clear(_nameField);
            _isEditValid = true;
            FormContext.NotifyValidationStateChanged();
            return;
        }

        _isEditValid = true;
        FormContext.NotifyValidationStateChanged();
    }


    private static string Normalize(string? name)
    {
        if (string.IsNullOrWhiteSpace(name))
            return string.Empty;

        var t = StringFormater.RemoveUnwantedChar(name);

        return t;
    }

    public void Dispose()
    {
        if (FormContext != null)
        {
            FormContext.OnFieldChanged -= HandleFieldChanged;
            FormContext.OnValidationRequested -= HandleValidationRequested;
        }
    }

    private async Task HandleSubmit()
    {
        Logger.Log(nameof(HandleSubmit), "Submiting.");
        Messages ??= new MessagesContainer();
        Messages.ClearAll();
        
        if (!ValidateModel(out MessagesContainer messages))
        {
            Logger.LogWarning(nameof(HandleSubmit), "Model not valid.");
            Messages.Append(messages);
            await OnMessages.InvokeAsync(Messages);
            return;
        }

        Messages.Append(messages);
        ConstructModel();
        
        await OnMessages.InvokeAsync(Messages);
        await OnSubmit.InvokeAsync(Model);
    }

    private void ConstructModel()
    {
        Model.Descriptor = EditDescriptor;
        
        var selectedBaseCat = SelectedBaseCategories.Count ==0 ? new() :  GetCategoryRefs(SelectedBaseCategories.Select(c=>c.ToString())) ?? new();

        Model.BasesCategory = selectedBaseCat;
        Model.Parent = ParentRef;
    }

    private bool ValidateModel(out MessagesContainer messages)
    {
        messages = new MessagesContainer();
        var currentDescriptorContent = Normalize(EditDescriptor.DescriptionContent);
        
        bool descriptionChanged = false;
        
        if (string.Equals(currentDescriptorContent, _originalDescriptorContent, StringComparison.InvariantCultureIgnoreCase))
        {
            messages.AddWarning($"Category {Model!.Name} description content did not change");
            EditDescriptor.ApplyRequest = Request.DontApplyRequest;
        }
        else
        {
            EditDescriptor.ApplyRequest = Request.ApplyRequest;
            descriptionChanged = true;
        }
        
        
        
        //todo check if changed
        bool anythingChangedInCategory = false;

        if (!_normalizedOriginalName.Equals(Normalize(Model.Name), StringComparison.InvariantCultureIgnoreCase))
        {
            anythingChangedInCategory = true;
            messages.AddInfo($"Changed Name to {Model.Name}");
        }
        else
        {
            messages.AddWarning($"Name Did not change");
        }
        
        if (!IsSameParent(Model.Parent, ParentRef))
        {
            anythingChangedInCategory = true;
            messages.AddInfo($"Changed Parent to {(ParentRef == null ? "None": ParentRef.Name  )}");
        }
        else
        {
            messages.AddWarning($"Parent Did not change");
        }
        
        var selectedBaseCat = SelectedBaseCategories.Count ==0 ? new() :  GetCategoryRefs(SelectedBaseCategories.Select(c=>c.ToString())) ?? new();
        
        if (!IsSameBaseCategory(Model.BasesCategory, selectedBaseCat))
        {
            anythingChangedInCategory = true;
            messages.AddInfo($"Changed Bases Categories");
        }
        else
        {
            messages.AddWarning($"Base Categories did not change");
        }
        
        
        Model.ApplyRequest = anythingChangedInCategory ? Request.ApplyRequest : Request.DontApplyRequest;
        var nothingChanged = !anythingChangedInCategory && !descriptionChanged;
        if(nothingChanged) messages.AddError("Wont Update : Nothing Changed in Category");
        return  anythingChangedInCategory || descriptionChanged ;
    }

    private bool IsValid()
    {
        //todo
        return true;
    }
    
    private bool IsSameBaseCategory(List<MovementCategoryRefDTO> editCategoryBasesCategory, List<MovementCategoryRefDTO> selectedBaseCat)
    {
        if(editCategoryBasesCategory.Count == 0 && selectedBaseCat.Count == 0)  return true;
        if(editCategoryBasesCategory.Count != selectedBaseCat.Count) return false;
        
        return editCategoryBasesCategory.SequenceEqual(selectedBaseCat);
    }

    private bool IsSameParent(MovementCategoryRefDTO? editCategoryParent, MovementCategoryRefDTO? parentRef)
    {
        if (editCategoryParent == null && parentRef == null) return true;
        if((editCategoryParent == null && parentRef != null) || (editCategoryParent != null && parentRef == null)) return false;
        return editCategoryParent!.Id == parentRef!.Id;
    }

    private List<MovementCategoryRefDTO>? GetCategoryRefs(IEnumerable<string>? names)
    {
        if (names == null || !names.Any())  return null;
        return AllCategories.Where(c => names.Contains(c.Name)).Select(c=>new MovementCategoryRefDTO(c.Id, c.Name)).ToList();
    }
}