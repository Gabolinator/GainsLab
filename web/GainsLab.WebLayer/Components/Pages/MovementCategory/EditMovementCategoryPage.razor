
@page "/movement-categories/{id:guid}"

@rendermode InteractiveServer

@using GainsLab.Application.DTOs
@using GainsLab.Application.Results
@using GainsLab.Contracts
@using GainsLab.Contracts.Dtos.Delete.Outcome
@using GainsLab.Contracts.Dtos.GetDto
@using GainsLab.Contracts.Dtos.ID
@using GainsLab.Contracts.Dtos.UpdateDto.Request
@using GainsLab.Domain.Interfaces
@using GainsLab.Infrastructure.Caching.Registry
@using GainsLab.WebLayer.Components.Control
@using GainsLab.WebLayer.Components.Control.MovementCategory
@using GainsLab.WebLayer.Model.Dto.Descriptor
@using GainsLab.WebLayer.Model.Dto.MovementCategory
@using GainsLab.WebLayer.Model.Notification
@using GainsLab.WebLayer.Model.Notification.Confirmation
@implements IDisposable
@inject NavigationManager NavManager;


<p>
    @if (EditCategory != null)
    {
        <MovementCategoryFormComponent FormName="muscleEditForm"
                                       Model="EditCategory"
                                       OnMessages="OnMessageFromForm"
                                       DisplayBackButton=@true
                                       BackButtonText="Close"
                                       SubmitButtonText="Update"
                                       AllCategories ="AllCategories"
                                       OnSubmit=@Update>
            
        </MovementCategoryFormComponent>
    }
    <br/>
    <br/>  @if (Category != null)
           {
               <button class="btn btn-primary" @onclick="Delete">Delete</button>
           }

    <MessageComponent Messages="@Messages"></MessageComponent>

</p>

@code {
    [Parameter] public Guid Id { get; set; } = Guid.Empty;

    [Inject] private ILogger Logger { get; set; } = default!;
    [Inject] private IClock Clock { get; set; } = default!;
    [Inject] private MovementCategoryRegistry Repo { get; set; } = default!;
    [Inject] private DescriptorRegistry DescriptorRegistry { get; set; } = default!;
    [Inject] private IToast Toast { get; set; } = default!;
    [Inject] private IConfirmDialog ConfirmDialog { get; set; } = default!;

    public MovementCategoryGetDTO? Category { get; set; } = null;
    public MovementCategoryEditFormDTO? EditCategory { get; set; } = null;
    
    
    private EditContext? FormContext;
    private ValidationMessageStore? _validationMessages;
    private FieldIdentifier _nameField;

    private bool _isEditValid = false;
  
    private IReadOnlyList<MovementCategoryGetDTO> _categories;
    private string _parentFieldID;
   
    public MessagesContainer? Messages { get; set; } = new MessagesContainer();

    public IReadOnlyList<MovementCategoryRefDTO> AllCategories { get; set; }


    protected override async Task OnParametersSetAsync()
    {
     
        await base.OnParametersSetAsync();
        Messages ??= new MessagesContainer();

        Messages.ClearAll();

        _isEditValid = false;

        //we cache all the Categorys - so we can filter for same name
        var eqs = await Repo.GetAllAsync();
        if (eqs.Value == null || eqs.Value.Count == 0)
        {
            Messages.AddError("No Categorys Found");
            return;
        }

        _categories = eqs.Value!;
        AllCategories=_categories.Select(c => new MovementCategoryRefDTO(c.Id, c.Name)).ToList();

        
        var eq =   _categories.FirstOrDefault(e => e.Id == Id);
        if (eq == null)
        {
            Messages.AddError("Category not found");
            return;
        }
        Category = eq;
        EditCategory = Category!.FromGetDTO();
        
    }



  

    public void Dispose()
    {
   
    }


    private async Task Update(MovementCategoryFormDTO form)
    {
       
        Messages ??= new MessagesContainer();
       

        if (form is not MovementCategoryEditFormDTO editForm)
        {
            Toast.Error($"Form type mismatch");
            return;
        }


        DescriptorUpdateRequest? descriptorUpdateRequest = null;
        if (editForm.Descriptor is DescriptorEditDTO descriptor)
        {
            descriptorUpdateRequest = descriptor.ToUpdateRequest();
        }
        
         var request = editForm.ToUpdateRequest();
       
         Messages.ClearAll();
        
         var outcome = await Repo.UpdateMovementCategoryAsync(request,  descriptorUpdateRequest);
        if (!outcome.Success || outcome.Value == null)
        {
            var message = "Could not update Category: ";
            Messages.AddError(message);
            Messages.Append(outcome.GetMessages());
            Toast.FromMessages(Messages);
        }
        
        else
        {
            Messages.Append(outcome.Value!.GetOutcomeMessages(outcome.GetMessages()));
        
            if (outcome.Value.MovementCategory != null && outcome.Value.MovementCategory.Outcome == UpdateOutcome.Updated)
                Toast.Success($"Category updated to {outcome.Value.MovementCategory.UpdatedState!.Name}");
        
            if (outcome.Value.Descriptor != null && outcome.Value.Descriptor.Outcome == UpdateOutcome.Updated)
                Toast.Success($"Category Description updated to {outcome.Value.Descriptor.UpdatedState!.content}");
        
        }

    }

   

    private async Task Delete()
    {

       
        Messages ??= new MessagesContainer();
        Messages.ClearAll();
        if (Category == null || Category.Id == Guid.Empty)
        {
            Messages.AddWarning("Invalid Category Id");
            Toast.Error($"Could not delete Category : Invalid Category");
            return;
        }

        var ok = await ConfirmDialog.ShowAsync(
            new ConfirmRequest(
                "Delete Item",
                $"Are You sure you want to delete Category '{Category.Name}' ? It can't be undone",
                "Delete",
                "Cancel",
                true));

        if (!ok)
        {
            Toast.Error($"Delete {Category.Name} Cancelled");
            return;
        }
        
        Toast.Error("Not Implemented");
        return;
        
        Result<MovementCategoryDeleteOutcome> outcome = await Repo.DeleteCategoryAsync(new MovementCategoryEntityId(Category.Id));
        if (!outcome.Success || outcome.Value is not { Outcome: DeleteOutcome.Deleted })
        {

            Messages.Append(outcome.Messages);
            Toast.Error($"Could not delete Category : {Messages.ToString(MessageType.Error)}");
            return;
        }

        var message = $"Category {outcome.Value.Id} Deleted";

        Messages.AddInfo(message);
        Toast.Success(message);
        NavManager.NavigateTo("Categorys");




    }

   
    private void OnMessageFromForm(MessagesContainer obj)
    {
       Messages = obj;
       Toast.FromMessages(Messages);
    }

}